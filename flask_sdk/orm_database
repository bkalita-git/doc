POSTGRESQL
arch linux setup:
	1. this creates a postgres user in system
		$ pacman -S postgresql
	2. login to postgres user 
		$ su -l postgres
	3. initialized database cluster by giving the location where database should be stored
		$ initdb -D /var/lib/postgres/data
	4. add a new database user 
		$createuser --interactive
	5. create database 
		$ createdb my_database_name -O newly_created_user
	6. loginto the database 
		$ psql -U newly_created_user -d my_database_name
	7.  add password to the user, after login to the database 
		=>ALTER USER newly_created_user WITH ENCRYPTED PASSWORD 'password';
		sudo nano /var/lib/postgres/data/postgresql.conf --> change trust to md5 in fist local
		sudo nano /var/lib/postgres/data/pg_hba.conf     --> password_encryption = md5
		sudo systemctl restart postgresql


#Remember, We don't want to login to the newly_created_user(since we did not give database creation priviliedge to that user so no system user will be created which can execute commands like "createdb" etc.) instead we will loginto the database using the newly_created_user and password if there is.
like this $ psql -U flask_test -d TESTSB
#PostgreSQL database user names are logically separate from user names of the operating system in which the server runs
#there need be no connection between database user names and OS user names.
#for exampple, the system user 'postgres' and the database user 'postgres' have no connection physically even though their password may same.
#that's why we can't do $ su -l database_user_name. because they are stored in table too.


Object Relational Mapper, can access/use relational 

$ pip install flask-sqlalchemy
$ pip install psycopg2 #python postgresql database adapter
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
app = Flask(...


#we need the database file inside our project directory
#config.py
	...
	SQLALCHEMY_DATABASE_URI = 'sqlite:///site.db' 
				or
	SQLALCHEMY_DATABASE_URI = 'postgresql://user_name:password@ip/database_name' #user_name, password and database_name should already be created
	...

db = SQLAlchemy(app)
#represents database as classes, can be in different file
#each class is a table in database

class User(db.Model):
	#columns_for_table
	id = db.Column(db.Integer,primary_key=True)
	username=db.Column(db.String(20),unique=True,nullable=False)
	email=db.Column(db.String(20),unique=True,nullable=False)
	image_file=db.Column(db.String(20),nullable=False, default='default.jpg')
	password=db.Column(db.String(60),nullable=False)
	
	post = db.relationship('Post',backref='author',lazy=True) #addding another hidden column author to Post
	
	#this is used by print function, so what this object return when print
	def __repr__(self):
		return f"User('{self.username}','{self.email}','{self.image_file}')"


class Post(db.Model):
	id=db.Column(db.Integer,primary_key=True)
	title=db.Column(db.String(100),nullable=False)
	date_posted=db.Column(db.DateTime,nullable=false,default=datetime.utcnow) #not passing  utcnow() because we need to send the function
	content = db.Column(db.Text,nullable=False)
	user_id = db.Column(db.Integer,db.ForeignKey('user.id'),nullable=False) #see lower case u,since real table will be made with lower case
	def __repr__(self):
		return f"User('{self.title}','{self.date_posted}')"
		

**Now table should be created before runing the flask app	
		
#command line
$python
>>> from  app_name import db #where db variable is
				or 
>>> import app; from app import db 
>>> db.create_all() #site.db file will be created
			or
>>> with app.app_context():
...     db.create_all()
>>> from app_name import User,Post
>>> user_1=User(username='Corey',email='C@demo.com',password="hashed_string_pass")
>>> db.session.add(user_1)
>>> db.session.commit()
>>> User.query.all() #all data
>>> User.query.first()
>>> User.query.filter_by(username='Corey').all()
>>> user = User.query.filter_by(username='Corey').first()
>>> user.id
>>> user = User.query.get(1) #1  is id
>>> db.drop_all() #all rows deleted we need db.create_all() after


---------------------------------------------------------------------------------------------------


#SQLAlchemy
	#pip install sqlalchemy
	
	#project/db.py
	from sqlalchemy import create_engine
	engine = create_engine('postgresql://flask_test:password@localhost/TESTSB')

	from sqlalchemy.orm import scoped_session, sessionmaker
	Session = scoped_session(sessionmaker(bind=engine))


	#project/app/__init__.py
	@app.teardown_appcontext
	def cleanup(resp_or_exc):
		Session.remove()


	#project/app/blueprints/Message/__init__.py
	from .db import Session
	from .models import Message
	from flask_restful import Resource
	class Message(Resource):
		def get():
			values = Session.query(Message).all()
			return ""


	#project/app/models.py
	from sqlalchemy.ext.declarative import declarative_base
	from sqlalchemy import Column,Integer,String
	Base=declarative_base()
	class Message(Base):
		__tablename__ = 'message'
		id = Column(Integer,primary_key=True)
		message = Column(String)
		
		def __repr__(self):
			return f"{self.message}"
	
	#creating tables from models
	from app import db
	from app import models



--------------------------------------------------------------------
//flask_sqlalchemy
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()
db.init_app(app)
class User(db.Model):
	 id = db.Column(db.Integer,primary_key=True)
db.session.query(User)
db.session.add(User(id=2))
db.session.commit()
db.create_all()

//sqlalchemy
from sqlalchemy import create_engine
engine = create_engine(SQLALCHEMY_DATABASE_URI)
from sqlalchemy.orm import sessionmaker,scoped_session
Session = scoped_session(sessionmaker(bind=engine))
from sqlalchemy.orm declarative_base
from sqlalchemy import Column,Integer
Base = declarative_base()
class User(Base):
	id = Column(Integer,primary_key=True)
Session.query(User)
Session.add(User(id=2))
Session.commit()

Base.metadata.bind = engine
Base.metadata.create_all()
--------------------------------------------------------------------

State of an Object
1. transient	: not in session also no database identity
2. pending		: when Session.add(transient_instance) it becones pending, but not commit	 
3. persistent	: flush the pending object. or query the database for existing instance
4. deleted		: instance deleted within a flush but no commit, when rolled back a deleted object moves to the persistent
5. detached		: the deleted object is committed. but no  session with it. a deleted object can't be in pending state.

@objects/instance of base_declaratives are tracked by orm.
@s1 = Session(), s2 = Session() both s1 and s2 commit will work for the same object iff Session is a scoped_session.
--------------------------------------------------------------------	
#REFERENCES
1.https://www.postgresql.org/docs/9.1/client-authentication.html
2.https://wiki.archlinux.org/title/PostgreSQL#Require_password_for_login
3.https://www.pythoncentral.io/understanding-python-sqlalchemy-session/
4.https://docs.sqlalchemy.org/en/14/orm/basic_relationships.html
