POSTGRESQL
arch linux setup:
	1. this creates a 'postgres' user in system
		$ pacman -S postgresql
	2. login to postgres user 
		$ su -l postgres
	3. initialized database cluster by giving the location where database should be stored
		$ initdb -D /var/lib/postgres/data
	4. add a new database user 
		$createuser --interactive
	5. create database 
		$ createdb my_database_name -O newly_created_user
	6. loginto the database 
		$ psql -U newly_created_user -d my_database_name
	7.  add password to the user, after login to the database 
		=>ALTER USER newly_created_user WITH ENCRYPTED PASSWORD 'password';
		sudo nano /var/lib/postgres/data/postgresql.conf --> change trust to md5 in fist local
		sudo nano /var/lib/postgres/data/pg_hba.conf     --> password_encryption = md5
		sudo systemctl restart postgresql

i. PostgreSQL database user names are logically separate from user names of the operating system in which the server runs
i. there need be no connection between database user names and OS user names.
i. for exampple, the system user 'postgres' and the database user 'postgres' have no connection physically even though their password may same.
i. that's why we can't do $ su -l database_user_name. because they are stored in table too.
i. Remember, We don't want to login to the newly_created_user(since we did not give database creation priviliedge to that user so no system user will be created which can execute commands like "createdb" etc.) instead we will loginto the database using the newly_created_user and password if there is.
like this $ psql -U flask_test -d TESTSB


TRANSACTION:
	A transaction contain many smaller tasks. transaction follows ACID property. 
	ATOMICITY: A transaction is either complete or not complete, It can't be partially completed.
	CONSISTENCY:
	ISOLATION: Different transaction can be happening simultaneously
	DURABILTY: Guarantee of data being stored once commit.
	
	a transaction can be ROLLBACK or COMMITED
	
	=> BEGIN;
	=> INSERT/UPDATE QUERY;
	=> COMMIT/ROLLBACK;
	
	
NORMALIZATION:
	No composite data in a column. table should not include frequent data. they should be broken into new table. because using relational algebra we can generate as many table we want.

INDEXING:
	when declaring 'PRIMARY KEY', it automatically  creates an index for the column, index helps to retrieve data quickly. indexig uses B+ data structure.
	we can creare an index manually by-
		=> CREATE INDEX index_name ON table_name(col_name);

RETRIEVING DATA:
	SELECT [*,COUNT(*),LENGTH(*),col_name, col_name AS new_col, count(DISTINCT col_name)]  
	FROM [table_name1,table_name2...] 
	JOIN [table...] ON [..id=..id] JOIN ... 
	WHERE [..id=..id, id.. LIKE/NOT LIKE ..id]
	GROUP BY [col_name/col_poition] HAVING [condition]
	ORDER BY [col_name/col_poition] ASC/DESC  #i. use col_poition for efficiency
	LIMIT [10/10,20]
	
lly,
	UPDATE, DELETE, INSERT

EXPLAIN:
	=> EXPLAIN QUERY;



Object Relational Mapper, can access/use relational 

$ pip install flask-sqlalchemy
$ pip install psycopg2 #python postgresql database adapter
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
app = Flask(...


#we need the database file inside our project directory
#config.py
	...
	SQLALCHEMY_DATABASE_URI = 'sqlite:///site.db' 
				or
	SQLALCHEMY_DATABASE_URI = 'postgresql://user_name:password@ip/database_name' #user_name, password and database_name should already be created
	...

db = SQLAlchemy(app)
#represents database as classes, can be in different file
#each class is a table in database

class User(db.Model):
	#columns_for_table
	id = db.Column(db.Integer,primary_key=True)
	username=db.Column(db.String(20),unique=True,nullable=False)
	email=db.Column(db.String(20),unique=True,nullable=False)
	image_file=db.Column(db.String(20),nullable=False, default='default.jpg')
	password=db.Column(db.String(60),nullable=False)
	
	post = db.relationship('Post',backref='author',lazy=True) #addding another hidden column author to Post
	
	#this is used by print function, so what this object return when print
	def __repr__(self):
		return f"User('{self.username}','{self.email}','{self.image_file}')"


class Post(db.Model):
	id=db.Column(db.Integer,primary_key=True)
	title=db.Column(db.String(100),nullable=False)
	date_posted=db.Column(db.DateTime,nullable=false,default=datetime.utcnow) #not passing  utcnow() because we need to send the function
	content = db.Column(db.Text,nullable=False)
	user_id = db.Column(db.Integer,db.ForeignKey('user.id'),nullable=False) #see lower case u,since real table will be made with lower case
	def __repr__(self):
		return f"User('{self.title}','{self.date_posted}')"
		

**Now table should be created before runing the flask app	
		
#command line
$python
>>> from  app_name import db #where db variable is
				or 
>>> import app; from app import db 
>>> db.create_all() #site.db file will be created
			or
>>> with app.app_context():
...     db.create_all()
>>> from app_name import User,Post
>>> user_1=User(username='Corey',email='C@demo.com',password="hashed_string_pass")
>>> db.session.add(user_1)
>>> db.session.commit()
>>> User.query.all() #all data
>>> User.query.first()
>>> User.query.filter_by(username='Corey').all()
>>> user = User.query.filter_by(username='Corey').first()
>>> user.id
>>> user = User.query.get(1) #1  is id
>>> db.drop_all() #all rows deleted we need db.create_all() after


---------------------------------------------------------------------------------------------------


#SQLAlchemy
	#pip install sqlalchemy
	
	#project/db.py
	from sqlalchemy import create_engine
	engine = create_engine('postgresql://flask_test:password@localhost/TESTSB')

	from sqlalchemy.orm import scoped_session, sessionmaker
	Session = scoped_session(sessionmaker(bind=engine))


	#project/app/__init__.py
	@app.teardown_appcontext
	def cleanup(resp_or_exc):
		Session.remove()


	#project/app/blueprints/Message/__init__.py
	from .db import Session
	from .models import Message
	from flask_restful import Resource
	class Message(Resource):
		def get():
			values = Session.query(Message).all()
			return ""


	#project/app/models.py
	from sqlalchemy.ext.declarative import declarative_base
	from sqlalchemy import Column,Integer,String
	Base=declarative_base()
	class Message(Base):
		__tablename__ = 'message'
		id = Column(Integer,primary_key=True)
		message = Column(String)
		
		def __repr__(self):
			return f"{self.message}"
	
	#creating tables from models
	from app import db
	from app import models



--------------------------------------------------------------------
//flask_sqlalchemy
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()
db.init_app(app)
class User(db.Model):
	 id = db.Column(db.Integer,primary_key=True)
db.session.query(User)
db.session.add(User(id=2))
db.session.commit()
db.create_all()

//sqlalchemy
from sqlalchemy import create_engine
engine = create_engine(SQLALCHEMY_DATABASE_URI)
from sqlalchemy.orm import sessionmaker,scoped_session
Session = scoped_session(sessionmaker(bind=engine))
from sqlalchemy.orm declarative_base
from sqlalchemy import Column,Integer
Base = declarative_base()
class User(Base):
	id = Column(Integer,primary_key=True)
Session.query(User)
Session.add(User(id=2))
Session.commit()

Base.metadata.bind = engine
Base.metadata.create_all()
--------------------------------------------------------------------
#Indexes used to retrieve data faster(primary_key)
#use logging (echo=True)to see what sql queries are producing to know performance
#concepts of transactions, join, sub-queries

#State of base_declarative Object
	'''  
	from sqlalchemy.orm import base_declarative
	Base = base_declarative()
	class User(Base):
		...
	
	base_declarative_object = User(id=...)
	'''
		
	1. transient	: not in session also no database identity
	2. pending		: when Session.add(transient_instance) it becones pending, but not commit	 
	3. persistent	: flush the pending object. or query the database for existing instance
	4. deleted		: instance deleted within a flush but no commit, when rolled back a deleted object moves to the persistent
	5. detached		: the deleted object is committed. but no  session with it. a deleted object can't be in pending state. or a previously persistent object is
					  no longer attached to a session.

	@objects/instance of base_declaratives are tracked by orm.
	for the same base_declarative_object you can't assign(session1.add(b_d_o), session2.add(b_d_o)) it to different session but it is possible if the session is scoped_session.
	after commiting a session all the transactions inside the session expires, but a session.rollback() will undo the commit

#identity map
	
#sessionmaker Session
	'''
	from sqlalchemy.orm import sessionmaker
	Session = sessionmaker(bind=engine)
	session1 = Session()
	
	session1.close()
	'''
#scoped_session Session
	'''
	from sqlalchemy.orm import sessionmaker,scoped_session
	ScopedSession = scoped_session(sessionmaker(bind=engine))
	session1 = ScopedSession()
	'''
--------------------------------------------------------------------	
#REFERENCES
1.https://www.postgresql.org/docs/9.1/client-authentication.html
2.https://wiki.archlinux.org/title/PostgreSQL#Require_password_for_login
3.https://www.pythoncentral.io/understanding-python-sqlalchemy-session/
4.https://docs.sqlalchemy.org/en/14/orm/basic_relationships.html
